
1.ContainsDuplicate 
In Java 
class Solution {
    public boolean containsDuplicate(int[] nums) {

        Set<Integer> set = new HashSet<>();
        for(int num : nums) {
            if(set.contains(num)){
                return true;
            }
            set.add(num);
        }
        return false;
    } 
}

In C#
public class Solution {
    public bool ContainsDuplicate(int[] nums) {
        HashSet<int> set = new HashSet<int>();
        foreach(int num in nums){
            if(set.Contains(num)){
                return true;
            }
            set.Add(num);
        }
        return false;
    }
}


2. Valid Anagram
In Java

class Solution {
    public boolean isAnagram(String s, String t) {
       if(s.length() != t.length()) return false;
        int[] counts = new int[26];

        for(int i = 0; i < s.length(); i++){
        counts[s.charAt(i) -'a']++;
        counts[t.charAt() - 'a']--;  
    }

    for(int count : counts){
        if(count != 0) 
        return false;
    }

    return true;
    } 

}

In C#
public class Solution {
    public bool IsAnagram(string s, string t) {
        if(s.Length != t.Length) return false;
        int[] counts = new int[26];

        for(int i = 0; i < s.Length; i++){
        counts[s[i] -'a']++;
        counts[t[i]-'a']--;  
    }

    foreach (int count in counts){
        if(count != 0) 
        return false;
    }

    return true;
    }
}


In Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer,Integer> map = new HashMap<>();

        for(int i = 0; i < nums.length; i++){
            int diff = target - nums[i];
        

        if(map.containsKey(diff)){
        return new int[] {map.get(diff), i};
        }
    
        map.put(nums[i], i);
        }
            throw new IllegalArgumentException("No two sum solution");
             
    }
}

In C#
public class Solution {
    public int[] TwoSum(int[] nums, int target) {
          Dictionary<int,int> map = new Dictionary<int, int>();

        for(int i = 0; i < nums.Length; i++){
            int diff = target - nums[i];
        

        if(map.ContainsKey(diff)){
        return new int[] {map[diff], i};
        }
    
        map[nums[i]] = i;
        }
            throw new ArgumentException("No two sum solution");
             
    }
    }


---------
In Java
public class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> res = new HashMap<>();
        for (String s : strs) {
            int[] count = new int[26];
            for (char c : s.toCharArray()) {
                count[c - 'a']++;
            }
            String key = Arrays.toString(count);
            res.putIfAbsent(key, new ArrayList<>());
            res.get(key).add(s);
        }
        return new ArrayList<>(res.values());
    }
}

In C#
public class Solution {
    public IList<IList<string>> GroupAnagrams(string[] strs) {
    
       Dictionary<string, List<string>> res = new Dictionary<string, List<string>>();

        foreach (string s in strs) {
            int[] count = new int[26];
            foreach (char c in s) {
                count[c - 'a']++;
            }

            // Convert the count array to a unique string key
            string key = string.Join(",", count);

            if (!res.ContainsKey(key)) {
                res[key] = new List<string>();
            }
            res[key].Add(s);
        }

        return new List<IList<string>>(res.Values);
    }
}
  
---------
5. In Java
public class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> count = new HashMap<>();
        List<Integer>[] freq = new List[nums.length + 1];

        for (int i = 0; i < freq.length; i++) {
            freq[i] = new ArrayList<>();
        }

        for (int n : nums) {
            count.put(n, count.getOrDefault(n, 0) + 1);
        }

        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
            freq[entry.getValue()].add(entry.getKey());
        }

        int[] res = new int[k];
        int index = 0;
        for (int i = freq.length - 1; i > 0 && index < k; i--) {
            for (int n : freq[i]) {
                res[index++] = n;
                if (index == k) {
                    return res;
                }
            }
        }
        return res;
    }
}

5. In C#
public class Solution {
    public int[] TopKFrequent(int[] nums, int k) {
         Dictionary<int, int> count = new Dictionary<int, int>();
        List<int>[] freq = new List<int>[nums.Length + 1];

        // Initialize buckets
        for (int i = 0; i < freq.Length; i++)
        {
            freq[i] = new List<int>();
        }

        // Count frequencies
        foreach (int n in nums)
        {
            if (!count.ContainsKey(n))
                count[n] = 0;
            count[n]++;
        }

        // Fill frequency buckets
        foreach (var entry in count)
        {
            int num = entry.Key;
            int frequency = entry.Value;
            freq[frequency].Add(num);
        }

        // Build result from high frequency down
        List<int> result = new List<int>();
        for (int i = freq.Length - 1; i > 0 && result.Count < k; i--)
        {
            foreach (int n in freq[i])
            {
                result.Add(n);
                if (result.Count == k)
                    return result.ToArray();
            }
        }

        return result.ToArray();
    }
}

------
6 In Java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];

        // Step 1: Calculate left products
        res[0] = 1;
        for (int i = 1; i < n; i++) {
            res[i] = res[i - 1] * nums[i - 1];
        }

        // Step 2: Multiply by right products
        int right = 1;
        for (int i = n - 1; i >= 0; i--) {
            res[i] = res[i] * right;
            right *= nums[i];
        }

        return res;
    }
    
}

6. In C#
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];

        // Step 1: Calculate left products
        res[0] = 1;
        for (int i = 1; i < n; i++) {
            res[i] = res[i - 1] * nums[i - 1];
        }

        // Step 2: Multiply by right products
        int right = 1;
        for (int i = n - 1; i >= 0; i--) {
            res[i] = res[i] * right;
            right *= nums[i];
        }

        return res;
    }
    
}
--------

7. In Java
 class Solution {
    public boolean isValidSudoku(char[][] board) {
         // Use sets to track seen numbers
        HashSet<Character>[] rows = new HashSet[9];
        HashSet<Character>[] cols = new HashSet[9];
        HashSet<Character>[] boxes = new HashSet[9];

        for (int i = 0; i < 9; i++) {
            rows[i] = new HashSet<>();
            cols[i] = new HashSet<>();
            boxes[i] = new HashSet<>();
        }

        // Traverse every cell
        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 9; c++) {
                char val = board[r][c];
                if (val == '.') continue;

                // Calculate index of 3x3 sub-box
                int boxIndex = (r / 3) * 3 + (c / 3);

                if (rows[r].contains(val) || cols[c].contains(val) || boxes[boxIndex].contains(val)) {
                    return false;
                }

                rows[r].add(val);
                cols[c].add(val);
                boxes[boxIndex].add(val);
            }
        }

        return true;
    }
}
7. In C#
public class Solution {
    public bool IsValidSudoku(char[][] board) {
        HashSet<char>[] rows = new HashSet<char>[9];
        HashSet<char>[] cols = new HashSet<char>[9];
        HashSet<char>[] boxes = new HashSet<char>[9];

        for (int i = 0; i < 9; i++) {
            rows[i] = new HashSet<char>();
            cols[i] = new HashSet<char>();
            boxes[i] = new HashSet<char>();
        }

        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 9; c++) {
                char val = board[r][c];
                if (val == '.') continue;

                int boxIndex = (r / 3) * 3 + (c / 3);

                if (rows[r].Contains(val) || cols[c].Contains(val) || boxes[boxIndex].Contains(val)) {
                    return false;
                }

                rows[r].Add(val);
                cols[c].Add(val);
                boxes[boxIndex].Add(val);
            }
        }

        return true;
    }
}
---------
8. In Java

class Solution {
    public int longestConsecutive(int[] nums) {
        HashSet<Integer> set = new HashSet<>();
        for (int num : nums) {
            set.add(num);
        }

        int longest = 0;

        for (int num : set) {
            // Only start counting when num is the start of a sequence
            if (!set.contains(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;

                while (set.contains(currentNum + 1)) {
                    currentNum++;
                    currentStreak++;
                }

                longest = Math.max(longest, currentStreak);
            }
        }

        return longest; 
    }
}

8. In C#

public class Solution {
    public int LongestConsecutive(int[] nums) {
         HashSet<int> set = new HashSet<int>(nums);
        int longest = 0;

        foreach (int num in set) {
            // Only start when num is the beginning of a sequence
            if (!set.Contains(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;

                while (set.Contains(currentNum + 1)) {
                    currentNum++;
                    currentStreak++;
                }

                longest = Math.Max(longest, currentStreak);
            }
        }

        return longest;
    }
}

----------------

9. In Java

class Solution {
    public boolean isPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;

        while (left < right) {
            // Skip non-alphanumeric characters
            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
                left++;
            }
            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
                right--;
            }

            // Compare characters after converting to lowercase
            if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {
                return false;
            }

            left++;
            right--;
        }

        return true;
    }
}

9. In C#

public class Solution {
    public bool IsPalindrome(string s) {
        int left = 0;
        int right = s.Length - 1;

        while (left < right) {
            // Skip non-alphanumeric characters
            while (left < right && !Char.IsLetterOrDigit(s[left])) {
                left++;
            }
            while (left < right && !Char.IsLetterOrDigit(s[right])) {
                right--;
            }

            // Compare characters (case-insensitive)
            if (Char.ToLower(s[left]) != Char.ToLower(s[right])) {
                return false;
            }

            left++;
            right--;
        }

        return true;
    }
}

---------------------

10. In Java 
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;

        while (left < right) {
            int sum = numbers[left] + numbers[right];

            if (sum == target) {
                // +1 because the problem is 1-indexed
                return new int[] { left + 1, right + 1 };
            } else if (sum < target) {
                left++; // Need a larger sum
            } else {
                right--; // Need a smaller sum
            }
        }

        // As per the problem, there's always exactly one solution
        return new int[0]; // Just to satisfy the return type
    }
}

10. In C#

public class Solution {
    public int[] TwoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.Length - 1;

        while (left < right) {
            int sum = numbers[left] + numbers[right];

            if (sum == target) {
                // Return 1-based indices
                return new int[] { left + 1, right + 1 };
            } else if (sum < target) {
                left++; // Increase the smaller number
            } else {
                right--; // Decrease the larger number
            }
        }

        return new int[0]; // Should not reach here (guaranteed one solution)
    }
}
-------------------------------------------

11. 3Sum

In Java class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
         List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums); // Step 1: Sort the array

        for (int i = 0; i < nums.length - 2; i++) {
            // Skip duplicates for the first number
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            int target = -nums[i]; // target for twoSum
            int left = i + 1;
            int right = nums.length - 1;

            // Two-pointer approach
            while (left < right) {
                int sum = nums[left] + nums[right];

                if (sum == target) {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                    // Skip duplicates for left and right
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;

                    left++;
                    right--;
                } else if (sum < target) {
                    left++; // Need a larger number
                } else {
                    right--; // Need a smaller number
                }
            }
        }

        return result;
    }
}

11. In C#

public class Solution {
    public IList<IList<int>> ThreeSum(int[] nums) {
        Array.Sort(nums);
        var result = new List<IList<int>>();

        for (int i = 0; i < nums.Length - 2; i++) {
            // Skip duplicates for the first number
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            int left = i + 1;
            int right = nums.Length - 1;
            int target = -nums[i];

            while (left < right) {
                int sum = nums[left] + nums[right];

                if (sum == target) {
                    result.Add(new List<int> { nums[i], nums[left], nums[right] });

                    // Skip duplicates for left and right
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;

                    left++;
                    right--;
                } else if (sum < target) {
                    left++;
                } else {
                    right--;
                }
            }
        }

        return result;
    }
}
------------

12. Container with most water
In Java 
class Solution {
    public int maxArea(int[] height) {
         int left = 0;
        int right = height.length - 1;
        int maxArea = 0;

        while (left < right) {
            int h = Math.min(height[left], height[right]);
            int w = right - left;
            int area = h * w;
            maxArea = Math.max(maxArea, area);

            // Move the pointer pointing to the shorter line
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }

        return maxArea;
    }
}

12. In C#

public class Solution {
    public int MaxArea(int[] height) {
       int left = 0;
        int right = height.Length - 1;
        int maxArea = 0;

        while (left < right) {
            int h = Math.Min(height[left], height[right]);
            int w = right - left;
            int area = h * w;

            maxArea = Math.Max(maxArea, area);

            // Move the pointer pointing to the shorter line
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }

        return maxArea;
    }
}

---------