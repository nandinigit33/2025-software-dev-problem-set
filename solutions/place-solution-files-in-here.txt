
1.ContainsDuplicate 
In Java 
class Solution {
    public boolean containsDuplicate(int[] nums) {

        Set<Integer> set = new HashSet<>();
        for(int num : nums) {
            if(set.contains(num)){
                return true;
            }
            set.add(num);
        }
        return false;
    } 
}

In C#
public class Solution {
    public bool ContainsDuplicate(int[] nums) {
        HashSet<int> set = new HashSet<int>();
        foreach(int num in nums){
            if(set.Contains(num)){
                return true;
            }
            set.Add(num);
        }
        return false;
    }
}


2. Valid Anagram
In Java

class Solution {
    public boolean isAnagram(String s, String t) {
       if(s.length() != t.length()) return false;
        int[] counts = new int[26];

        for(int i = 0; i < s.length(); i++){
        counts[s.charAt(i) -'a']++;
        counts[t.charAt() - 'a']--;  
    }

    for(int count : counts){
        if(count != 0) 
        return false;
    }

    return true;
    } 

}

In C#
public class Solution {
    public bool IsAnagram(string s, string t) {
        if(s.Length != t.Length) return false;
        int[] counts = new int[26];

        for(int i = 0; i < s.Length; i++){
        counts[s[i] -'a']++;
        counts[t[i]-'a']--;  
    }

    foreach (int count in counts){
        if(count != 0) 
        return false;
    }

    return true;
    }
}


In Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer,Integer> map = new HashMap<>();

        for(int i = 0; i < nums.length; i++){
            int diff = target - nums[i];
        

        if(map.containsKey(diff)){
        return new int[] {map.get(diff), i};
        }
    
        map.put(nums[i], i);
        }
            throw new IllegalArgumentException("No two sum solution");
             
    }
}

In C#
public class Solution {
    public int[] TwoSum(int[] nums, int target) {
          Dictionary<int,int> map = new Dictionary<int, int>();

        for(int i = 0; i < nums.Length; i++){
            int diff = target - nums[i];
        

        if(map.ContainsKey(diff)){
        return new int[] {map[diff], i};
        }
    
        map[nums[i]] = i;
        }
            throw new ArgumentException("No two sum solution");
             
    }
    }


---------
In Java
public class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> res = new HashMap<>();
        for (String s : strs) {
            int[] count = new int[26];
            for (char c : s.toCharArray()) {
                count[c - 'a']++;
            }
            String key = Arrays.toString(count);
            res.putIfAbsent(key, new ArrayList<>());
            res.get(key).add(s);
        }
        return new ArrayList<>(res.values());
    }
}

In C#
public class Solution {
    public IList<IList<string>> GroupAnagrams(string[] strs) {
    
       Dictionary<string, List<string>> res = new Dictionary<string, List<string>>();

        foreach (string s in strs) {
            int[] count = new int[26];
            foreach (char c in s) {
                count[c - 'a']++;
            }

            // Convert the count array to a unique string key
            string key = string.Join(",", count);

            if (!res.ContainsKey(key)) {
                res[key] = new List<string>();
            }
            res[key].Add(s);
        }

        return new List<IList<string>>(res.Values);
    }
}
  
---------
5. In Java
public class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> count = new HashMap<>();
        List<Integer>[] freq = new List[nums.length + 1];

        for (int i = 0; i < freq.length; i++) {
            freq[i] = new ArrayList<>();
        }

        for (int n : nums) {
            count.put(n, count.getOrDefault(n, 0) + 1);
        }

        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
            freq[entry.getValue()].add(entry.getKey());
        }

        int[] res = new int[k];
        int index = 0;
        for (int i = freq.length - 1; i > 0 && index < k; i--) {
            for (int n : freq[i]) {
                res[index++] = n;
                if (index == k) {
                    return res;
                }
            }
        }
        return res;
    }
}

5. In C#
public class Solution {
    public int[] TopKFrequent(int[] nums, int k) {
         Dictionary<int, int> count = new Dictionary<int, int>();
        List<int>[] freq = new List<int>[nums.Length + 1];

        // Initialize buckets
        for (int i = 0; i < freq.Length; i++)
        {
            freq[i] = new List<int>();
        }

        // Count frequencies
        foreach (int n in nums)
        {
            if (!count.ContainsKey(n))
                count[n] = 0;
            count[n]++;
        }

        // Fill frequency buckets
        foreach (var entry in count)
        {
            int num = entry.Key;
            int frequency = entry.Value;
            freq[frequency].Add(num);
        }

        // Build result from high frequency down
        List<int> result = new List<int>();
        for (int i = freq.Length - 1; i > 0 && result.Count < k; i--)
        {
            foreach (int n in freq[i])
            {
                result.Add(n);
                if (result.Count == k)
                    return result.ToArray();
            }
        }

        return result.ToArray();
    }
}

------
6 In Java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];

        // Step 1: Calculate left products
        res[0] = 1;
        for (int i = 1; i < n; i++) {
            res[i] = res[i - 1] * nums[i - 1];
        }

        // Step 2: Multiply by right products
        int right = 1;
        for (int i = n - 1; i >= 0; i--) {
            res[i] = res[i] * right;
            right *= nums[i];
        }

        return res;
    }
    
}

6. In C#
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];

        // Step 1: Calculate left products
        res[0] = 1;
        for (int i = 1; i < n; i++) {
            res[i] = res[i - 1] * nums[i - 1];
        }

        // Step 2: Multiply by right products
        int right = 1;
        for (int i = n - 1; i >= 0; i--) {
            res[i] = res[i] * right;
            right *= nums[i];
        }

        return res;
    }
    
}
--------